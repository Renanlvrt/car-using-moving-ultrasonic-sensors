{"entries":[{"timestamp":1756880984492,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":233,"diffs":[[1,""]]},{"start1":1,"length1":5238,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":141,"length1":164,"diffs":[[1,"        \"microphone\": \"*\"\n"]]},{"start1":231,"length1":39,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":258,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"main.py","value":"\"\"\"\ndef on_button_pressed_a():\n    global on\n    motobit.enable(MotorPower.ON)\n    motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 100)\n    motobit.set_motor_speed(Motor.RIGHT, MotorDirection.FORWARD, 100)\n    on = True\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n\ndef on_button_pressed_b():\n    global on\n    pins.servo_write_pin(AnalogPin.P15, 90)\n    pause(100)\n    motobit.enable(MotorPower.OFF)\n    led.unplot(0, 0)\n    on = False\n\ninput.on_button_pressed(Button.B, on_button_pressed_b)\n\non = False\nmanouvering = False\n# TURN LEFT: pins.servo_write_pin(AnalogPin.P15, 37)\n# TURN RIGHT: pins.servo_write_pin(AnalogPin.P15, 160)\n# neutral: pins.servo_write_pin(AnalogPin.P15, 90)\nmotobit.invert(Motor.LEFT, True)\nmotobit.invert(Motor.RIGHT, True)\nmotobit.enable(MotorPower.OFF)\ndistance = sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS)\nserial.write_value(\"distance\", distance)\n# serial.writeNumber(sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS));\n\n#try building another forever loop?\ndef on_forever():\n    motobit.invert(Motor.LEFT, True)\n    motobit.invert(Motor.RIGHT, True)\n    global distance\n    global manouvering\n    global on\n    on = True\n    distance = sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS)\n    led.plot(0, 0)\n    # serial.write_number(distance)\n    serial.write_value(\"distance\", distance)\n    serial.write_line(\"\" + str((on)))\n    serial.write_line(\"\" + str((manouvering)))\n    if on:\n        if not (manouvering):\n            while distance < 3500:\n                basic.clear_screen()\n                serial.write_value(\"in the cycle\", distance)\n                led.unplot(0, 0)\n                #not to forget to update distance in the while\n                distance = sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS)\n                manouvering = True\n                motobit.enable(MotorPower.ON)\n                led.plot(2, 2)\n                if distance < 1500:\n                    #led.plot(4,4)\n                    led.plot(2, 1)\n                    led.plot(2, 3)\n                    led.plot(1, 2)\n                    led.plot(3, 2)\n                    #again same problem\n                    motobit.enable(MotorPower.OFF)\n                    pins.servo_write_pin(AnalogPin.P15, 160)\n                    pause(300)\n                    motobit.enable(MotorPower.ON)\n                    motobit.set_motor_speed(Motor.LEFT, MotorDirection.REVERSE, 100)\n                    motobit.set_motor_speed(Motor.RIGHT, MotorDirection.REVERSE, 100)\n                    pause(1000)\n                    # pins.servo_write_pin(AnalogPin.P15, 37)\n                    # motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 60)\n                    # motobit.set_motor_speed(Motor.RIGHT, MotorDirection.FORWARD, 60)\n                    # pause(1000)\n                    led.unplot(2, 2)\n                    led.unplot(2, 1)\n                    led.unplot(2, 3)\n                    led.unplot(1, 2)\n                    led.unplot(3, 2)\n                    #led.unplot(4,4)\n                    #manouvering = False\n                else:\n                    led.plot(2, 2)\n                    #to avoid turning while going forward\n                    #motobit.enable(MotorPower.OFF)\n                    pins.servo_write_pin(AnalogPin.P15, 30)\n                    #pause(300)\n                    #motobit.enable(MotorPower.ON)\n                    motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 70)\n                    motobit.set_motor_speed(Motor.RIGHT, MotorDirection.FORWARD, 70)\n                    pause(350)\n                    led.unplot(2, 2)\n            ##manouvering2 = False\n            motobit.enable(MotorPower.OFF)\n            pins.servo_write_pin(AnalogPin.P15, 90)\n            motobit.enable(MotorPower.ON)\n            motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 100)\n            motobit.set_motor_speed(Motor.RIGHT, MotorDirection.FORWARD, 100)\n            # motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 50)\n            basic.clear_screen()\n            #not to forget to update manouvering\n            manouvering = False\nbasic.forever(on_forever)\n\"\"\"\n\ndef on_button_pressed_a():\n    global on\n    motobit.enable(MotorPower.ON)\n    motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 100)\n    motobit.set_motor_speed(Motor.RIGHT, MotorDirection.FORWARD, 100)\n    on = True\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n\ndef on_button_pressed_b():\n    global on\n    pins.servo_write_pin(AnalogPin.P15, 90)\n    pause(100)\n    motobit.enable(MotorPower.OFF)\n    led.unplot(0, 0)\n    on = False\n\ninput.on_button_pressed(Button.B, on_button_pressed_b)\n\non = False\nmanouvering = False\n# TURN LEFT: pins.servo_write_pin(AnalogPin.P15, 37)\n# TURN RIGHT: pins.servo_write_pin(AnalogPin.P15, 160)\n# neutral: pins.servo_write_pin(AnalogPin.P15, 90)\nmotobit.invert(Motor.LEFT, True)\nmotobit.invert(Motor.RIGHT, True)\nmotobit.enable(MotorPower.OFF)\ndistance = sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS)\nserial.write_value(\"distance\", distance)\n# serial.writeNumber(sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS));\n\n#try building another forever loop?\ndef on_forever():\n    global distance\n    motobit.invert(Motor.LEFT, True)\n    motobit.invert(Motor.RIGHT, True)\n    pins.servo_write_pin(AnalogPin.P16, 90)\n    pause(2000)\n    pins.servo_write_pin(AnalogPin.P16, 180)\n    pass\nbasic.forever(on_forever)\n\n\n\n\n\n\n\n"}]},{"timestamp":1756881577903,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4305,"length1":0,"diffs":[[1,"    motobit.enable(MotorPower.On)\n    motobit.setMotorSpeed(Motor.Left, MotorDirection.Forward, 100)\n    motobit.setMotorSpeed(Motor.Right, MotorDirection.Forward, 100)\n    on = true\n"]]},{"start1":4561,"length1":0,"diffs":[[1,"    pins.servoWritePin(AnalogPin.P15, 90)\n    pause(100)\n    motobit.enable(MotorPower.Off)\n    led.unplot(0, 0)\n    on = false\n"]]},{"start1":4692,"length1":0,"diffs":[[1,"let on = false\nlet manouvering = false\n//  TURN LEFT: pins.servo_write_pin(AnalogPin.P15, 37)\n//  TURN RIGHT: pins.servo_write_pin(AnalogPin.P15, 160)\n//  neutral: pins.servo_write_pin(AnalogPin.P15, 90)\nmotobit.invert(Motor.Left, true)\nmotobit.invert(Motor.Right, true)\nmotobit.enable(MotorPower.Off)\nlet distance = sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MicroSeconds)\nserial.writeValue(\"distance\", distance)\n//  serial.writeNumber(sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS));\n"]]},{"start1":5283,"length1":0,"diffs":[[1,"    \n"]]},{"start1":5421,"length1":47,"diffs":[[1,"    pins.servoWritePin(AnalogPin.P16, 180)\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":4261,"length1":9,"diffs":[[1,"    global on\n    motobit.enable(MotorPower.ON)\n    motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 100)\n    motobit.set_motor_speed(Motor.RIGHT, MotorDirection.FORWARD, 100)\n    on = True\n"]]},{"start1":4546,"length1":9,"diffs":[[1,"    global on\n    pins.servo_write_pin(AnalogPin.P15, 90)\n    pause(100)\n    motobit.enable(MotorPower.OFF)\n    led.unplot(0, 0)\n    on = False\n"]]},{"start1":4747,"length1":0,"diffs":[[1,"on = False\nmanouvering = False\n# TURN LEFT: pins.servo_write_pin(AnalogPin.P15, 37)\n# TURN RIGHT: pins.servo_write_pin(AnalogPin.P15, 160)\n# neutral: pins.servo_write_pin(AnalogPin.P15, 90)\nmotobit.invert(Motor.LEFT, True)\nmotobit.invert(Motor.RIGHT, True)\nmotobit.enable(MotorPower.OFF)\ndistance = sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS)\nserial.write_value(\"distance\", distance)\n# serial.writeNumber(sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS));\n"]]},{"start1":5299,"length1":0,"diffs":[[1,"    global distance\n"]]},{"start1":5454,"length1":45,"diffs":[[1,"    pins.servo_write_pin(AnalogPin.P16, 180)\n"]]}]}]},{"timestamp":1756881722257,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":4550,"length1":42,"diffs":[[1,"    pins.servo_write_pin(AnalogPin.P16, 90)\n"]]}]}]},{"timestamp":1756884638296,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":4550,"length1":43,"diffs":[[1,"    pins.servo_write_pin(AnalogPin.P16, )\n"]]}]}]},{"timestamp":1756884638715,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4532,"length1":457,"diffs":[[1,"    pins.servoWritePin(AnalogPin.P16, 90)\n    pause(2000)\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":4550,"length1":404,"diffs":[[1,"    pins.servo_write_pin(AnalogPin.P16, 0)\n    pause(2000)\n"]]}]}]},{"timestamp":1756885238454,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4373,"length1":43,"diffs":[[1,""]]},{"start1":4457,"length1":44,"diffs":[[1,""]]},{"start1":4532,"length1":45,"diffs":[[1,"    for (let angle = 90; angle < 3; angle++) {\n"]]},{"start1":4702,"length1":17,"diffs":[[1,"        pause(30)\n"]]},{"start1":4726,"length1":262,"diffs":[[1,"    led.unplot(0, 0)\n    // pins.servo_write_pin(AnalogPin.P16, 180)    #position initial\n"]]},{"start1":4835,"length1":68,"diffs":[[1,"    // pins.servo_write_pin(AnalogPin.P16, 270)    #position gauche\n"]]},{"start1":4922,"length1":66,"diffs":[[1,"    // pins.servo_write_pin(AnalogPin.P16, 90)    #position droite\n    // pins.servo_write_pin(AnalogPin.P16, 60)\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":4354,"length1":46,"diffs":[[1,""]]},{"start1":4475,"length1":21,"diffs":[[1,""]]},{"start1":4550,"length1":33,"diffs":[[1,"    for angle in range(90, ):\n"]]},{"start1":4683,"length1":255,"diffs":[[1,"        pause(30)\n    led.unplot(0, 0)\n    #pins.servo_write_pin(AnalogPin.P16, 180)    #position initial\n"]]},{"start1":4806,"length1":66,"diffs":[[1,"    #pins.servo_write_pin(AnalogPin.P16, 270)    #position gauche\n"]]},{"start1":4889,"length1":64,"diffs":[[1,"    #pins.servo_write_pin(AnalogPin.P16, 90)    #position droite\n    #pins.servo_write_pin(AnalogPin.P16, 60)\n"]]}]}]},{"timestamp":1756885835962,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":237,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":4373,"length1":0,"diffs":[[1,"    pins.servoSetPulse(AnalogPin.P0, 1500)\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":415,"length1":44,"diffs":[[1,""]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":4354,"length1":0,"diffs":[[1,"\n    pins.servo_set_pulse(AnalogPin.P0, 1500)\n"]]}]},{"type":"added","filename":"test.ts","value":"// les tests vont ici ; cela ne sera pas compilé si ce paquet est utilisé en tant qu'extension.\n"}]}],"snapshots":[{"timestamp":1756880984491,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"car using moving ultrasonic sensors\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1756884638296,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"","README.md":"","main.py":"\"\"\"\ndef on_button_pressed_a():\n    global on\n    motobit.enable(MotorPower.ON)\n    motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 100)\n    motobit.set_motor_speed(Motor.RIGHT, MotorDirection.FORWARD, 100)\n    on = True\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n\ndef on_button_pressed_b():\n    global on\n    pins.servo_write_pin(AnalogPin.P15, 90)\n    pause(100)\n    motobit.enable(MotorPower.OFF)\n    led.unplot(0, 0)\n    on = False\n\ninput.on_button_pressed(Button.B, on_button_pressed_b)\n\non = False\nmanouvering = False\n# TURN LEFT: pins.servo_write_pin(AnalogPin.P15, 37)\n# TURN RIGHT: pins.servo_write_pin(AnalogPin.P15, 160)\n# neutral: pins.servo_write_pin(AnalogPin.P15, 90)\nmotobit.invert(Motor.LEFT, True)\nmotobit.invert(Motor.RIGHT, True)\nmotobit.enable(MotorPower.OFF)\ndistance = sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS)\nserial.write_value(\"distance\", distance)\n# serial.writeNumber(sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS));\n\n#try building another forever loop?\ndef on_forever():\n    motobit.invert(Motor.LEFT, True)\n    motobit.invert(Motor.RIGHT, True)\n    global distance\n    global manouvering\n    global on\n    on = True\n    distance = sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS)\n    led.plot(0, 0)\n    # serial.write_number(distance)\n    serial.write_value(\"distance\", distance)\n    serial.write_line(\"\" + str((on)))\n    serial.write_line(\"\" + str((manouvering)))\n    if on:\n        if not (manouvering):\n            while distance < 3500:\n                basic.clear_screen()\n                serial.write_value(\"in the cycle\", distance)\n                led.unplot(0, 0)\n                #not to forget to update distance in the while\n                distance = sonar.ping(DigitalPin.P12, DigitalPin.P14, PingUnit.MICRO_SECONDS)\n                manouvering = True\n                motobit.enable(MotorPower.ON)\n                led.plot(2, 2)\n                if distance < 1500:\n                    #led.plot(4,4)\n                    led.plot(2, 1)\n                    led.plot(2, 3)\n                    led.plot(1, 2)\n                    led.plot(3, 2)\n                    #again same problem\n                    motobit.enable(MotorPower.OFF)\n                    pins.servo_write_pin(AnalogPin.P15, 160)\n                    pause(300)\n                    motobit.enable(MotorPower.ON)\n                    motobit.set_motor_speed(Motor.LEFT, MotorDirection.REVERSE, 100)\n                    motobit.set_motor_speed(Motor.RIGHT, MotorDirection.REVERSE, 100)\n                    pause(1000)\n                    # pins.servo_write_pin(AnalogPin.P15, 37)\n                    # motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 60)\n                    # motobit.set_motor_speed(Motor.RIGHT, MotorDirection.FORWARD, 60)\n                    # pause(1000)\n                    led.unplot(2, 2)\n                    led.unplot(2, 1)\n                    led.unplot(2, 3)\n                    led.unplot(1, 2)\n                    led.unplot(3, 2)\n                    #led.unplot(4,4)\n                    #manouvering = False\n                else:\n                    led.plot(2, 2)\n                    #to avoid turning while going forward\n                    #motobit.enable(MotorPower.OFF)\n                    pins.servo_write_pin(AnalogPin.P15, 30)\n                    #pause(300)\n                    #motobit.enable(MotorPower.ON)\n                    motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 70)\n                    motobit.set_motor_speed(Motor.RIGHT, MotorDirection.FORWARD, 70)\n                    pause(350)\n                    led.unplot(2, 2)\n            ##manouvering2 = False\n            motobit.enable(MotorPower.OFF)\n            pins.servo_write_pin(AnalogPin.P15, 90)\n            motobit.enable(MotorPower.ON)\n            motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 100)\n            motobit.set_motor_speed(Motor.RIGHT, MotorDirection.FORWARD, 100)\n            # motobit.set_motor_speed(Motor.LEFT, MotorDirection.FORWARD, 50)\n            basic.clear_screen()\n            #not to forget to update manouvering\n            manouvering = False\nbasic.forever(on_forever)\n\"\"\"\n\ndef on_button_pressed_a():\n    pass\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n\ndef on_button_pressed_b():\n    pass\n\ninput.on_button_pressed(Button.B, on_button_pressed_b)\n\n\n#try building another forever loop?\ndef on_forever():\n    motobit.invert(Motor.LEFT, True)\n    motobit.invert(Motor.RIGHT, True)\n    pins.servo_write_pin(AnalogPin.P16, 90)\n    pause(2000)\n    #pins.servo_write_pin(AnalogPin.P16, 60)\n    pass\nbasic.forever(on_forever)\n\n\n\n\n\n\n\n","pxt.json":"{\n    \"name\": \"car using moving ultrasonic sensors\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"servo\": \"*\",\n        \"pxt-sonar\": \"github:microsoft/pxt-sonar#v0.0.6\",\n        \"motobit\": \"github:sparkfun/pxt-moto-bit#v0.0.4\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}}],"shares":[],"lastSaveTime":1756885936060}